# 背景知识科普

## Unix & Linux

大致是这样的，1965年，贝尔实验室、MIT和通用一起搞了个项目，要开发一个分时多任务操作系统，叫MULTICS，项目很牛逼，计划做很大，然后车翻了，没搞成。  
贝尔实验的一个中二青年肯汤普森经历翻车后回到实验室，觉得MULTICS的那帮货都是脑残，看我自己搞一个，然后在一台PDP-7小型机（相当于是现在的小霸王学习机）上基于MULTICS中的一些想法，自己开发了一个简陋的寨版系统，Unics（1969年）。（系统很好用，很牛逼，但有个毛病，就是只能跑在小霸王上，如果要换平台，就得重新写一遍代码，虽然能混KPI，但从设计角度讲比较智障。于是中二青年就拉了个小伙伴组成基佬组，再开发了一个叫C语言的东东（2B的B语言咱略过），然后把Unics用C语言重写了一编，改名Unix（1971年），其中x就是cross的略写，跨平台的意思。那会儿软件版权意识是不存在的，Unix出来后，很多企业和学校都觉得很好，代码研究了一番后，都尝试模仿，其中就有伯克里大学仿写的BSD系统（1978年）。其中BSD系统早期基本就是Unix系统，但贝尔实验室一天不知道哪根筋搭错（嗯，评论区有帅哥补充说是BSD先商业化导致贝尔实验室告BSD侵权），突然发现Unix是个大商机，于是将伯克里大学告上了法庭，要求伯克里大学停止使用BSD系统，成了知名的IT业界大案，与后面的巨硬垄断案基本齐名。经过各种扯皮后，最终结果是BSD以及一些其他的非贝尔实验室的UNIX系统去除全部Unix代码或花钱购买许可而告终。所以，在该案前，BSD和一些其他的山寨Unix系统 = Unix，而该案后，BSD其实与Unix已经没有了关系，变成了Unix-like系统，也就是类Unix系统。时间一晃到了1987年，有个叫弹您爸（Andrew Stuart Tanenbaum）的老教授，专门在诸如MIT和加州大学讲操作系统，但是各个大学的操作系统各有差异，为了教学方便，就自己开发了一个叫Minix的教学用Unix-Like系统，然后还写了本叫《操作系统的设计与实现》的鸟书骗老子这样的傻子钱，Minix的源码就带在了下册里。1988年，芬兰赫尔辛基大学又有一个特别特别特别中二的青年（大家都知道是谁）正苦于实验室里只有一台Unix机器+16个位子，和老板关系不好的一般占不到，于是想给自己的IBM PC也整个Unix系统。然后偶然发现了谭宁邦的Minix，学习一番后，觉得这东西有点二，于是自己也写了个玩玩，冠名为Linux。

___

Unix 现在只是一个商标，并没有哪一个操作系统名称叫做 "Unix"。如果一个操作系统在技术上符合了 Unix 的规范，又得到了商标使用许可，那么它可以称自己为 Unix，否则只能算 Unix-like（类 Unix）。所以你可以将 Unix 看做一种类别，而非具体的操作系统。Linux 是参照 Unix 设计出来的，但并没有基于当时现有的任何一款 Unix 系统，所以 Linux 和 Unix 有许多本质上的相似性但也存在大量的差异以及 Linux 独特的地方。因为 Unix 操作系统五花八门，为了保证软件的兼容性，诞生了一套叫做 POSIX 系统接口的标准。其中 POSI 四个字母是 Portable Operating System Interface（可移植操作系统接口）的缩写，最后的 X 代表其是对 Unix 接口的传承。但 POSIX 并不是 Unix 系操作系统特有的，Linux 很早就完整的实现了 POSIX。所以许多软件能在 Linux 和 Unix 系系统上通用。并且 Windows 也是 POSIX 的实现系统之一。所以部分资料以 Linux 为基础讲 Unix 编程，这是完全可行的，但这不表示 Linux 是 Unix。在知乎这种地方强调过无数遍了，Linux 不是 Unix！Linux 不是 Unix！Linux 不是 Unix！

___

Unix是70年代和80年代非常流行且非常先进的商业操作系统。unix最大的问题是作为商业操作系统使用成本非常高，所以在1991，出现了一个实现了一个类似unix的操作系统linux。注意，linux不是unix，它是一个外表看上去象unix，但是实现方法上和unix完全无关的新的操作系统。此外linux不是商业软件，可以免费使用并且开放源代码。
总而言之：  
1，unix出现在前，linux出现在后并且实现了unix大多数功能，但还是存在区别；2，unix是商业软件并且不开放源代码，linux是自由软件并且开放源代码；

___

UNIX是商业系统。自由斗士理查德 Stallman非常讨厌商业软件。他决定要做一个自由的操作系统，并且向下兼容UNIX。于是他发起了GNU计划。gnu是角马的意思，又是GNU is not UNIX的意思。搞了好些年之后，万事俱备就差一个内核。这时候一个芬兰的大学生Linus 托瓦茨把他自己写的一个内核项目取名为Linux kernel发布到了朋友圈求点赞。于是两者一拍即合，整合成为了gnu-linux操作系统，并且一直作为开源系统在开发维护。由于Linus本人不像Stallman那么神经兮兮，在圈内口碑也比较好，此外开源社区的影响力也比自由软件斗士影响力大，慢慢的人们就把这个操作系统称为了Linux操作系统（把GNU忽视了）。为此Stallman 非常不满。

___

## Shell

操作系统分为内核(kernel)和外壳(shell)，Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。  
bash的故事更曲折，它是“Bourne again shell”的简称 。Bourne shell 是 Unix 最初使用的 shell，并且在每种 Unix 上都可以使用，虽然它在编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。说到底，shell这个物种，不仅要功能强大，而且还需要容易上手，毕竟shell是“人-机”交互的接口，不同于其他的编程语言，它们侧重于后台批处理任务，与人的交互不是首要考虑的问题。而shell要做到“通机器，懂人性”，这样才能有更多的受众人群。后来，创始人 Bourne 决定赋予 Bourne shell 新的生命，使其更适合于交互式使用，因此开创了新的项目并命名为 “Bourne again shell”，简称 “Bash”，也有好事者称 Bash 为 “重生shell(born again shell)”。Bash 是 Bourne shell 的扩展，与 Bourne shell 完全向后兼容，并且在Bourne shell 的基础上增加和增强了很多特性。可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。所以，Linux 操作系统缺省的 shell 是 Bash。

另，其他常见shell:

![](../../resources/pictures/2021-05-22-14-36-52.png)

### shell , console, terminal 的区别

1.终端是一个在窗口中绘制文本的程序，它会在屏幕上显示输出，也能让你通过键盘输入内容。准确讲，应该被称为「终端模拟器」，是对早年老式终端机的一种模拟程序。终端本身并不知道如何处理你的输入内容，它只是把你输入的东西发送给某个独立的处理程序(并不一定是Shell，终端完全可以不依赖Shell运行各种终端程序。比如你在Python解释器的终端中，就可以通过这种终端发送一段 Python脚本给Python解释器运行;你也可以在通常所说的终端中直接指定不是 Shell的特定的处理程序）。

2.Shell是上一点所说的「独立的处理程序」的一种，它能将你输入的内容解释为命令，确定你想运行的程序并运行之，然后将输出发回给终端。顾名思义，你可以把 Shell当作OS外的一层[壳」，可以用来与OS内核进行交互。你同样可以在不使用终端的情况下使用Shell，比如 Shell脚本编程，把命令写在文本文件中，然后直接从文件中运行Shell程序。

3.Shell有很多种, bash 就是其中目前使用最广泛的一种。

___

所以说，windows的cmd（全称为Command shell,也叫命令提示符）和 powershell，unix的bash都是一种shell，而 默认的conhost.exe (也就是那个黑框框）则是终端。

对于powershell，还可以使用如Fluent Terminal，Hyper，Terminus的第三方终端。

另，shell是一种命令解释器，也是用户操作接口，Linux用户通过我们通过输入一系列的指令，被shell解释后调用需要的系统接口，从而操纵系统内核，完成期望的动作。反过来，解释器并不一定就是shell。
