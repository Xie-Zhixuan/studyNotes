# <https://wangdoc.com/bash/expansion.html#navbar>

Shell 接
收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。

这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。

- 波浪线扩展
- `?`字符扩展
- `*`字符扩展
- 方括号扩展
- 大括号扩展
- 变量扩展
- 子命令扩展
- 算术扩展
  
本章介绍这八种扩展。

Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。

模块扩展的英文单词是globbing，这个词来自于早期的 Unix 系统有一个/etc/glob文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。

模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。

Bash 允许用户关闭扩展。
___

## `~`

波浪线~会自动扩展成当前用户的主目录。

## `?`

`?`字符代表文件路径里面的任意单个字符，不包括空字符。

如果匹配多个字符，就需要多个?连用。

? 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。

```
# 当前目录有 a.txt 文件
$ echo ?.txt
a.txt

# 当前目录为空目录
$ echo ?.txt
?.txt
```

上面例子中，如果?.txt可以扩展成文件名，echo命令会输出扩展后的结果；如果不能扩展成文件名，echo就会原样输出?.txt。

## `*`

*字符代表文件路径里面的任意数量的任意字符，包括零个字符。

如果想输出当前目录的所有文件，直接用*即可。

注意，`*`不会匹配隐藏文件（以.开头的文件），即`ls *`不会输出隐藏文件。

如果要匹配隐藏文件，需要写成.*。

同 `?`, `*`字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。

`*`和`?`只匹配当前目录，不会匹配子目录。

所以,若 文本文件在子目录，`*.txt`不会产生匹配，必须写成`*/*.txt`。有几层子目录，就必须写几层星号。

## 方括号扩展

方括号扩展的形式是[...]，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，[aeiou]可以匹配五个元音字母中的任意一个。

方括号扩展还有两种变体：[^...]和[!...]。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，[^abc]或[!abc]表示匹配除了a、b、c以外的字符。

```
# 存在 aaa、bbb、aba 三个文件
$ ls ?[!a]?
aba bbb
```

上面命令中，[!a]表示文件名第二个字符不是a的文件名，所以返回了aba和bbb两个文件。

注意，如果需要匹配[字符，可以放在方括号内，比如[[aeiou]。

## [start-end] 扩展

方括号扩展有一个简写形式[start-end]，表示匹配一个连续的范围。比如，[a-c]等同于[abc]，[0-9]匹配[0123456789]。

## 大括号扩展

大括号扩展{...}表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，{1,2,3}扩展成1 2 3。

注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。

```
$ ls {a,b,c}.txt
ls: 无法访问'a.txt': 没有那个文件或目录
ls: 无法访问'b.txt': 没有那个文件或目录
ls: 无法访问'c.txt': 没有那个文件或目录
```

上面例子中，即使不存在对应的文件，{a,b,c}依然扩展成三个文件名，导致ls命令报了三个错误。

另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。

```
$ echo {1 , 2}
{1 , 2}
```

大括号可以嵌套。

## {start..end} 扩展

大括号扩展有一个简写形式{start..end}，表示扩展成一个连续序列。比如，{a..z}可以扩展成26个小写英文字母。

## 变量扩展

Bash 将美元符号`$`开头的词元视为变量，将其扩展成变量值，

变量名除了放在美元符号后面，也可以放在`${}`里面。

## 子命令扩展

`$(...)`可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。

还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。

## 算术扩展

`$((...))`可以扩展成整数运算的结果，

## 字符类

[[:class:]]表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。

- [[:alnum:]]：匹配任意英文字母与数字
- [[:alpha:]]：匹配任意英文字母
- [[:blank:]]：空格和 Tab 键。
- [[:cntrl:]]：ASCII 码 0-31 的不可打印字符。
- [[:digit:]]：匹配任意数字 0-9。
- [[:graph:]]：A-Z、a-z、0-9 和标点符号。
- [[:lower:]]：匹配任意小写字母 a-z。
- [[:print:]]：ASCII 码 32-127 的可打印字符。
- [[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。
- [[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。
- [[:upper:]]：匹配任意大写字母 A-Z。
- [[:xdigit:]]：16进制字符（A-F、a-f、0-9）。

请看下面的例子。

`$ echo [[:upper:]]*`  
上面命令输出所有大写字母开头的文件名。

字符类的第一个方括号后面，可以加上感叹号!，表示否定。比如，`[![:digit:]]`匹配所有非数字。

`$ echo [![:digit:]]*`
上面命令输出所有不以数字开头的文件名。

字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。

```
# 不存在以大写字母开头的文件
$ echo [[:upper:]]*
[[:upper:]]*
```

上面例子中，由于没有可匹配的文件，字符类就原样输出了。

## 使用注意点

- 通配符是先解释，再执行。
- 文件名扩展在不匹配时，会原样输出。
- 只适用于单层路径。
- 文件名可以使用通配符
  
Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。

## 量词用法

## shopt命令

shopt命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。
